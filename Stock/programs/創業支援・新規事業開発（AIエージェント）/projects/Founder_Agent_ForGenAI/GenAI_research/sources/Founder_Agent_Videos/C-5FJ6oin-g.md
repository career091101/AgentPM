---
title: "当ではIQツールキットPYON ライブラリーについてご説明いたします。 IQツールキットPython ライブラリーはエンタープライズ開発者が 様々な大規模言語モデルフレームワークの コンポーネントをまとめたり、自身で コンポーネントを構築し"
video_id: "C-5FJ6oin-g"
video_url: "https://www.youtube.com/watch?v=C-5FJ6oin-g"
speaker: "Unknown"
channel: "Unknown"
date: ""
duration: ""
tags: ["AI", "LLM", "Development"]
topics: ["AI", "LLM", "Development"]
summary: |
  当ではIQツールキットPYON ライブラリーについてご説明いたします。 IQツールキットPython ライブラリーはエンタープライズ開発者が 様々な大規模言語モデルフレームワークの コンポーネントをまとめたり、自身で コンポーネントを構築したりすることで エージェント型AIアプリケーションを 開発できるように設計されています。この ような大規模言語モデルフレームワークの 例としてはラングチェーンやラマ インデックスーAIセマンティック カーネルなどが上げられます。統一された プログラミングモデルのもこれらの フレームワーク感を柔軟に移動できること でチーム間でも高い柔軟性と再利用性を 実現できます。こうしたアプリケーション を構築するチームは実際にはIQプラグ インを作成することになります。IQ プラグインはPipでインストール可能な Pythonパッケージとして作成され ます。PIPでインストールされたプラグ インはチームのどのメンバーでも使用でき ます。IQではこうしたパッケージに含め られる様々な種類のコンポーネントが用意 されています。次はこれらの コンポーネントの種類について見ていき ましょう。1つ目は大規模言語モデルです 。ではホスティングされている大規模言語 モデルとの通信が可能なクライアントを 認識し構築することができます。これらの 大規模言語モデルはエージェント型AI アプリケーションを支える主要なリーズ エンジンです。エンベッダーについても 同様です。エンベッダーはレトリーバー タイプのロジックでの作業時に適してい ます 。関数やツール。これらは通常特定の機能 を追加するためにLLMエージェントに 対して指定します。関数やツールは エージェントに対して指定するだけでなく 、通常のPython関数として直接 呼び出すこともできます 。レトリーバーはベクトル
key_points:
  - "Covers technology concepts and applications"
  - "Discusses AI, LLM, Development"
  - "Suitable for learning and reference"
category: "Technology"
confidence_level: "medium"
source: "Founder_Agent_Videos"
retrieved_at: "2025-12-30T10:04:35+09:00"
---

# Transcript: C-5FJ6oin-g

- URL: https://www.youtube.com/watch?v=C-5FJ6oin-g
- Retrieved at: 2025-12-30T10:04:35+09:00

## Text

- [00:03] 当ではIQツールキットPYON
- [00:06] ライブラリーについてご説明いたします。
- [00:09] IQツールキットPython
- [00:10] ライブラリーはエンタープライズ開発者が
- [00:13] 様々な大規模言語モデルフレームワークの
- [00:16] コンポーネントをまとめたり、自身で
- [00:18] コンポーネントを構築したりすることで
- [00:21] エージェント型AIアプリケーションを
- [00:23] 開発できるように設計されています。この
- [00:26] ような大規模言語モデルフレームワークの
- [00:28] 例としてはラングチェーンやラマ
- [00:31] インデックスーAIセマンティック
- [00:34] カーネルなどが上げられます。統一された
- [00:37] プログラミングモデルのもこれらの
- [00:39] フレームワーク感を柔軟に移動できること
- [00:42] でチーム間でも高い柔軟性と再利用性を
- [00:45] 実現できます。こうしたアプリケーション
- [00:48] を構築するチームは実際にはIQプラグ
- [00:51] インを作成することになります。IQ
- [00:54] プラグインはPipでインストール可能な
- [00:57] Pythonパッケージとして作成され
- [00:59] ます。PIPでインストールされたプラグ
- [01:02] インはチームのどのメンバーでも使用でき
- [01:04] ます。IQではこうしたパッケージに含め
- [01:08] られる様々な種類のコンポーネントが用意
- [01:11] されています。次はこれらの
- [01:13] コンポーネントの種類について見ていき
- [01:15] ましょう。1つ目は大規模言語モデルです
- [01:18] 。ではホスティングされている大規模言語
- [01:22] モデルとの通信が可能なクライアントを
- [01:25] 認識し構築することができます。これらの
- [01:29] 大規模言語モデルはエージェント型AI
- [01:31] アプリケーションを支える主要なリーズ
- [01:34] エンジンです。エンベッダーについても
- [01:37] 同様です。エンベッダーはレトリーバー
- [01:40] タイプのロジックでの作業時に適してい
- [01:42] ます
- [01:43] 。関数やツール。これらは通常特定の機能
- [01:48] を追加するためにLLMエージェントに
- [01:50] 対して指定します。関数やツールは
- [01:54] エージェントに対して指定するだけでなく
- [01:56] 、通常のPython関数として直接
- [01:59] 呼び出すこともできます
- [02:01] 。レトリーバーはベクトルデータベース
- [02:04] などとやり取りするための
- [02:06] インターフェースを提供します。また
- [02:09] エバリューエーターはエージェント型AI
- [02:11] アプリケーションの制度を評価し、
- [02:14] パフォーマンスを計測することで
- [02:16] デプロイジにホットスポットを特定し、
- [02:19] スループットを最大化できるようにします
- [02:21] 。さらにレジストリハンドラーは任意の
- [02:25] レジストリにパッケージをデプロイする
- [02:27] ためのインターフェイスを提供します。
- [02:30] これにより他の開発者がフロントエンドを
- [02:33] 利用し、アプリケーションにアクセス
- [02:35] できるようになります。これからファスト
- [02:38] APIエンドポイントを使用してそれが
- [02:41] どのように機能するのか、UIにどのよう
- [02:44] に接続するのか。そして最後にパッケージ
- [02:47] について見ていきます。先にお話しした
- [02:50] ように全てPipでインストール可能な
- [02:53] プラグインパッケージとして提供される
- [02:55] ため開発速度を最大限に高めることができ
- [02:58] ます。それでは少し詳しく見てみましょう
- [03:02] 。左側に見えているのはVSCDのIDE
- [03:06] です。そして右側はIQツールkitット
- [03:10] ライブラリーに付属しているUIです。
- [03:13] まず行うのはコアライブラリに含まれ
- [03:16] システムに登録されていてすぐに使い始め
- [03:19] られるコンポーネントの種類を確認する
- [03:21] ことで、これは開発者であれば気になる
- [03:24] ところでしょう。ここで
- [03:26] はインフォーティリティを使って全ての
- [03:29] コンポーネントを確認してみます。
- [03:31] コンポーネントタイプの列には先ほど上げ
- [03:34] たコンポーネントの種類がいくつか表示さ
- [03:36] れています。フロントエンドがあり、関数
- [03:40] があり、下にスクロールするとLLMや
- [03:44] エンベッダーなどもあります。上に
- [03:47] スクロールして1番上に戻ると特に重要な
- [03:50] 点がいくつかあります。コンポーネント
- [03:53] タイプとコンポーネントネームはローカル
- [03:56] システム内での登録名です。これらの名前
- [03:59] を使用してヤム設定ファイルからこれらの
- [04:03] コンポーネントを参照することになります
- [04:05] 。こちらについては後ほどご説明します。
- [04:09] そして1番右にはシステムの実行時の機能
- [04:13] を決定するためにヤムルでこれらの
- [04:16] コンポーネントに対して設定可能な
- [04:18] パラメーターが表示されています。それで
- [04:21] はまずシステムの使用方法を紹介するため
- [04:25] 簡単な計算機アプリケーションを作成して
- [04:27] みましょう。これらのコンポーネントが
- [04:30] コアライブラリ内または現在登録されて
- [04:33] いるコンポーネントにすでに含まれている
- [04:36] かを確認します。そのため検索
- [04:39] パラメーターとしてカリキュレーターと
- [04:41] 指定して検索を行います。現在使用可能な
- [04:45] コンポーネントはないようですので全てを
- [04:48] 1から書かなければなりません。IQ
- [04:50] ツールキットはコミュニティ思考の
- [04:53] ライブラリーなので、別のチームがこれを
- [04:55] もにすでにアプリケーションを構築してい
- [04:57] て、私たちがこのアプリケーションを使用
- [05:00] したいと考えているという状況を指定して
- [05:03] みましょう。実際ここにはいくつかの
- [05:06] サンプルが用意されており、その1つが
- [05:08] シンプルな計算器です。それではこれを
- [05:12] pipでインストールしてみましょう
- [05:17] 。これによりそのパッケージと全ての
- [05:20] プラグインがインストールされ、IQに
- [05:22] 登録されます。そのため先ほどと同じ
- [05:26] クエリを実行すると新たに登録された
- [05:28] コンポーネントがいくつか表示され使用
- [05:31] できるようになっているはずです。これで
- [05:34] IQを拡張できました。コードを1行も
- [05:37] 書くことなく他の人が行った作業を活用
- [05:40] できます。またヤムルファイルを設定する
- [05:44] ために使用するパラメーターも確認でき
- [05:46] ます。次はIQプラグインパッケージとは
- [05:50] 何かを見てみましょう。これは典型的な
- [05:53] PYProject......ILです
- [05:55] 。ここで注目すべき主な違いはこの
- [05:59] セクションです。このセクションは
- [06:01] レジスタープラグインの場所を示してい
- [06:03] ます。これによりIQに登録され名前で
- [06:07] 認識され、IQで構築されたエージェント
- [06:10] 型AIワークフローで使用できるように
- [06:12] なります。次はヤムルファイルを見てみ
- [06:15] ます。
- [06:17] ヤムルファイルではこれらの
- [06:19] コンポーネントを使用し、エンドポイント
- [06:21] を公開するワークフローを実行時にどの
- [06:24] ように設定するか、そしてこのエンド
- [06:27] ポイントとどのようにやり取りするかが
- [06:29] 示されています。最初のセクションでは
- [06:32] ワークフローに対するかの一般的な設定を
- [06:35] 指定します
- [06:36] 。テレメトリーの下でログ設定を指定し
- [06:40] ます
- [06:41] 。コンソールにログを出力し、ローカル
- [06:44] ファイルにもログを出力します。また
- [06:48] システム上で実行しているフェニックス
- [06:50] サーバーにもオープンテレメトリー形式の
- [06:52] トレースを送信します
- [06:54] 。次のセクションではフロントエンドを
- [06:57] 設定します。このワークフローで
- [07:00] はファストAPIエンドポイントを起動し
- [07:02] ます。また関数の1つに対するパスを作成
- [07:06] します。実際にどうなっているのかを見て
- [07:10] みましょう。初期設定ではワークフローに
- [07:14] 対して4つのルートが作成されます。その
- [07:17] うち2つはジェネートとジェネート
- [07:20] ストreームに対応するルートです。これ
- [07:23] らのルートにより比較的一般的な形式の
- [07:26] 入力をワークフローに渡すことができます
- [07:29] 。チャットとストreamではOpen
- [07:32] AI形式の入力を行えます。そして設定
- [07:36] ファイルで指定したこの新しいルートでは
- [07:39] アプリケーションのメインエントリー
- [07:41] ポイントを通してではなく関数の1つに
- [07:44] 直接リクエストを送信できます。これは
- [07:48] 様々な場合に役に立ちます
- [07:50] 。次はいくつかの関数やツールを見てみ
- [07:54] ましょう。4つのツールがあります。上山
- [07:59] 、不、助産、日時の4つのツールです。
- [08:04] このエントリーポイントはこの特定の
- [08:06] ツールにマッピングされています。この次
- [08:09] のセクションに進む前に少し戻ってご説明
- [08:12] します。ここでもう1度検索
- [08:15] インターフェイスを開いてみると
- [08:17] パラメーターの1つにこのアンダースコア
- [08:20] タイプがあります。このパラメーターは
- [08:23] こちらで使われています。コンポーネント
- [08:26] の名前を指定する必要があり、名前は
- [08:28] こちらにあります。このようにこれらの各
- [08:32] 関数に対する名前を指定し、また実行時の
- [08:36] インスタンス名も指定します。これらの
- [08:39] 名前が一致する必要はありませんが、この
- [08:42] 方法で実行時に関数にアクセスできるよう
- [08:45] になります。こちらの関数には長い就職名
- [08:49] が指定されています。インストールされて
- [08:51] いるコンポーネントの数が増えると名前が
- [08:54] 衝突する可能性があるため、各ツールには
- [08:58] 長い就職名が割り当てられています。次の
- [09:01] セクションはLLMです。ここではラマ
- [09:05] 3.370B指示モデルに対するNDIA
- [09:09] インファレンスマイクロサービスと
- [09:13] OpenAIモデルの2つを設定してい
- [09:15] ます。このデモではニムのみを使用し、
- [09:19] この名前でアクセスします。そしてこちら
- [09:21] の最後のセクションはワークフローです。
- [09:25] ワークフローにも他と同様にタイプ
- [09:27] パラメーターがあります。ここでは
- [09:29] 組み込みのリアクトエージェントを使用
- [09:32] することを指定します。コアライブラリー
- [09:35] の一部であり4つのツールを割り当てます
- [09:37] 。これらのツールは上で指定した名前に
- [09:41] よって定義されます。実行時の
- [09:44] インスタンス名でアクセスします。この大
- [09:47] 規模言語モデルをリーズの基盤として使用
- [09:50] することを指定します。いくつかの追加の
- [09:53] パラメーターも指定します
- [09:55] 。この組み込みのリアクトエージェントを
- [09:59] 使用しなければならないわけではありませ
- [10:01] ん
- [10:02] 。使用したい別のエージェントがある場合
- [10:05] はそのエージェントを使用し、この後にご
- [10:08] 紹介するIQデコレーターフレームワーク
- [10:11] 内に実装することもできます。これで全て
- [10:14] インストールしたのでこのワークフローを
- [10:16] 起動してテストできます。まずはIQ
- [10:20] ツールキットのサーブコマンドを使用し
- [10:22] ます。この設定ファイルへのパスを指定し
- [10:26] ます
- [10:29] 。ローカルでホスティングするために
- [10:32] ポート8000を使用し、これを起動し
- [10:35] ます
- [10:37] 。起動したら簡単な計算の問題を出すこと
- [10:41] ができます。それではこのワークフローが
- [10:44] 答えられる問題を出してみましょう。
- [10:57] まだサーバーが起動中のようですので、
- [10:59] もう1回試してみます
- [11:01] 。もういいでしょう
- [11:04] 。サーバーがメッセージを受け取りました
- [11:07] 。中間ステップがUIにストリーミングさ
- [11:11] れています。リーズながらこの計算機
- [11:15] ツールが必要であると判断してそのツール
- [11:18] を呼び出し回答を出していることが分かり
- [11:21] ます。いいですね。それではもう少し
- [11:24] 難しい質問をしてみましょう
- [11:27] 。この質問に答えるには複数のツールを
- [11:31] 使用する必要があり、そのうちの1つ、
- [11:35] つまり現在の時刻ツールはコア
- [11:37] ライブラリーに含まれています。この他に
- [11:41] プラグインパッケージに含まれていた
- [11:43] ザー山や不闘ツールも使用します。そして
- [11:47] ご覧のように正しい答えを出せています。
- [11:51] これらのツールを全て呼び出し、中間
- [11:54] ステップをUIにストリーミングした後、
- [11:57] 最終的な回答を示されています。次はこの
- [12:01] ワークフローの能力を超えるような質問を
- [12:03] してみましょう
- [12:05] 。約1ヶ月前に開催されたスーパーボール
- [12:09] の情報はこのモデルのトレーニングデータ
- [12:12] には含まれていないため、質問に答えよう
- [12:15] としてもうまくいかないだろうと予想され
- [12:17] ます。ご覧のように2025年のスーパー
- [12:22] ボールでどのチームが勝ったかを知るため
- [12:24] の最新情報がないことを素早く認識してい
- [12:28] ます。この2025年は現在の日ツールに
- [12:32] よって導き出されています。このワーク
- [12:35] フローを拡張することで質問に答えられる
- [12:38] ようにすることができます。それでは実際
- [12:42] にどのように拡張するかを見ていき
- [12:44] ましょう。このアプリケーションを停止し
- [12:47] ます。そしてIQツールkitット
- [12:50] ワークフローを使用して新たな
- [12:52] コンポーネントのための足場を構築します
- [12:54] 。ここでの目標はこの質問に答えられる
- [12:58] ワークフローを作成するために元のワーク
- [13:01] フローを拡張し誰でもPipで
- [13:03] インストール可能なPYONパッケージを
- [13:06] 作成することです。IQを拡張します。
- [13:11] IQ
- [13:13] ワークフロークリエイトヘルプメニューを
- [13:15] 表示します。いいですね。
- [13:19] IQ
- [13:22] workロークリエイトデフォルトで
- [13:23] インストールしないように指定します
- [13:27] 。Exampleディレクトリに作成し、
- [13:30] Wikキペディiaサーチという名前にし
- [13:32] ます
- [13:34] 。ここではエージェントが現在の日付を
- [13:38] 確認後、クラウドソーシングされている
- [13:41] インターネット百貨時点にアクセスして
- [13:43] 最新情報を得られるようにWiキペディア
- [13:46] ツールを作成します。
- [13:49] ここで行ったのはそのための足場を構築
- [13:52] することです。ご覧のようにPY
- [13:55] Project.Tomムルを作成しまし
- [13:57] た
- [13:58] 。プラグインを登録できるようにこの特別
- [14:02] なセクションを追加しました。こちらに
- [14:05] 作成されたソースファイルがあります。
- [14:08] このファイル内のいくつかの重要な項目を
- [14:11] ご紹介します
- [14:12] 。設定オブジェクトがあります。これに
- [14:16] ついてはヤムファイルの設定方法の説明時
- [14:19] に触れましたが、ヤムファイル内の全ての
- [14:22] パラメーターは設定対象のコンポーネント
- [14:26] の設定オブジェクトによって制御されます
- [14:28] 。そのため新しいwikキペディアツール
- [14:31] 用にオブジェクトを設定する必要があり
- [14:34] ます
- [14:35] 。この実装は下のこの部分で行っている
- [14:39] ためこの実装を更新しなければなりません
- [14:42] 。これらの作業が完了したらパッケージを
- [14:46] インストールします。このパッケージは
- [14:49] このワークフロー用に作成するヤムル
- [14:51] ファイルで使用できるようになります。
- [14:54] あるチームメンバーがこの
- [14:56] Wiキペディiaと一緒に使える
- [14:58] 素晴らしいユーティリティ機能を作成して
- [15:00] いるとしましょう。実際にはこれはラング
- [15:03] チェーンコミュニティから入手したもの
- [15:05] ですが、特定のフレームワークでどのよう
- [15:08] に使用すべきかを示しています。ここで
- [15:11] 内部関数を更新します
- [15:14] 。全体をコピーします。別のインポートが
- [15:18] 必要なようですので、こちらから取得し
- [15:20] ます。MAックスresultもコピー
- [15:23] する必要があります
- [15:25] 。こちらに挿入します。インポートを挿入
- [15:30] します
- [15:31] 。他のユーザーが各フィールドの意味を
- [15:34] 理解できるようにピーダンティック
- [15:36] フィールドを使用して新しい
- [15:38] コンポーネントについて記述します。
- [15:42] 1つの関数だけなので、他のユーザーが
- [15:44] 混乱しないようにワークフロー関連の名称
- [15:48] を削除します。これをユーティリティ機能
- [15:52] で使用されていた用語のMAッリ
- [15:54] resultで更新します
- [15:56] 。MAresultリザルツに変更します
- [16:01] 。整数にして初期設定値として1を指定し
- [16:06] ます
- [16:09] 。他のユーザーがこのフィールドの意味を
- [16:12] 理解できるようにマキシマム最大という
- [16:16] 説明を追加します
- [16:20] 。ここで入力パラメーターをクエスチョン
- [16:23] に更新します
- [16:24] 。これは重要です。この実行時
- [16:28] パラメーターには設定オブジェクトから
- [16:31] 直接アクセスするためです。この値は
- [16:35] ヤムルファイルで設定された値になります
- [16:37] 。ここで1度これまでの作業を振り返り
- [16:41] ましょう。設定オブジェクトを作成しまし
- [16:44] た。この設定オブジェクトを渡すことで
- [16:48] この関数をIQに登録しました
- [16:50] 。各コンポーネントには実行時
- [16:54] パラメーターにアクセスするための設定
- [16:56] オブジェクトとビルダーオブジェクトの2
- [16:59] つのパラメーターが付属しています。この
- [17:02] ビルダーオブジェクトが優れている点は
- [17:04] 例えばより高度な関数の場合この中から
- [17:08] 実際にLLMに直接アクセスできるという
- [17:11] ところです。例えばLLM=build
- [17:16] .getllmと指定できます。設定
- [17:20] ファイルに対するLLM名やラッパーの
- [17:23] 種類も指定できます
- [17:25] 。このように詳しく見ていくと、IQ
- [17:29] コンポーネントのどの関数内にも完全な
- [17:32] エージェントを実装することが可能であり
- [17:34] 、非常に強力なツールであることがお
- [17:37] 分かりいただけるでしょう。関数内から他
- [17:40] の関数を呼び出すことができるのです。何
- [17:43] 層にもネストされたエージェントを実装し
- [17:46] て非常に高度なワークフローを構築でき
- [17:48] ます
- [17:49] 。関数の取得に関しても同じことが行え
- [17:53] ます
- [17:54] 。エンベッダーやその他の項目の取得に
- [17:58] ついても同様です。ただしここではメイン
- [18:02] エージェントがアクセスする簡単なツール
- [18:04] として扱います。ここまでスキップします
- [18:07] 。簡単です。しなければならないことは
- [18:12] これくらいで、あとはもう1つだけです。
- [18:16] 関数です
- [18:17] 。ここで内部関数と説明を指定します
- [18:22] 。エージェントはツールの呼び出しを行う
- [18:25] ため、エージェントがそのツールの機能を
- [18:27] 認識できるように説明を含める必要があり
- [18:30] ます
- [18:33] 。このためここではドッグストリングから
- [18:36] 情報をコピーし
- [18:39] てこちらに貼り付け保存します
- [18:44] 。これで完了です
- [18:46] 。次に必要なのは設定ファイルです
- [18:51] 。前回と同様に設定ファイルを作成します
- [18:55] 。実際には同僚が作成した設定を流用し
- [18:59] ますが、ここに挿入して保存します
- [19:03] 。唯一行うことはこちらに新しい
- [19:07] wikキペディアツールを追加すること
- [19:08] です。実際にはその作業の前に少し簡単に
- [19:13] するためにこの新しいプラグイン
- [19:15] パッケージをインストールしておきます。
- [19:18] 名前はwikipペディiaサーチとし
- [19:20] ます。
- [19:26] これにより、先ほど構築したものが全て
- [19:29] 取り込まれ、インストールされ、登録され
- [19:32] ます。そのためIQインフコンポーネント
- [19:36] を実行してWikキペディアサーチを検索
- [19:39] する
- [19:43] とヤムルファイルに必要な情報を得ること
- [19:46] ができます。
- [19:51] 薬ざが必要なの
- [19:53] で3にしておきます。名前が必要なので
- [19:58] こちらからコピーします。そしてそれを
- [20:02] エージェントに対して指定します
- [20:06] 。保存します。続いてこの新しい
- [20:10] ワークフローをサーブします
- [20:13] 。前回と同じコマンドですが新しい設定
- [20:17] ファイルのバスに変更します。
- [20:27] 軌動を待つ間こちらでフェニックスの
- [20:29] トレースを見てみましょう
- [20:31] 。トレースをこちらに送信していたことで
- [20:35] 大規模言語モデルが何を行ってきているの
- [20:37] かを書化された分かりやすいログームで
- [20:40] 確認できます。それではこの新しいツール
- [20:44] で再度実行し質問に対してより適切に答え
- [20:48] られるかを見てみましょう。先ほど作成し
- [20:52] た新しいWiiキペディiaツールにより
- [20:55] システムが拡張されました
- [20:57] 。学習済みの知識を保管するために
- [21:01] シンプルな計算ツールに加え、クラウド
- [21:03] ソーシングされているインターネット百貨
- [21:06] 時点の情報をエージェントにできるように
- [21:08] なりました
- [21:10] 。これで質問に答えられるようになります
- [21:13] 。確認してみましょう
- [21:16] 。きちんと答えられたようです。
- [21:19] フィラデルフィアイーグルスが観察シティ
- [21:22] チーフスを破りスーパーボールを制した
- [21:24] こと。そして得典も返されています
- [21:28] 。ここまでをまとめますと、IQを使って
- [21:33] コアライブラリーに含まれる
- [21:34] コンポーネントを確認しました
- [21:36] 。いくつか足りないものがあったため、
- [21:39] 同僚が作成したプラグインパッケージを
- [21:41] 活用しました。そしてワークフローを起動
- [21:45] し、UIを返してそのワークフローと
- [21:47] やり取りしました。その後モデルが
- [21:51] トレーニングされたデータとアクセス
- [21:53] できるツールでは答えられない質問がある
- [21:55] ことが分かりました。次にカスタム関数を
- [21:59] 作成してワークフローを拡張し設定
- [22:02] ファイルを更新し、新しいプラグイン
- [22:05] パッケージを作成してインストールし、
- [22:08] アプリケーションをデプロイしました。
- [22:11] そして問題を解決できることを実証しまし
- [22:14] た
- [22:15] 。この過程で同僚に配布できるプラグイン
- [22:19] パッケージも作成しました
- [22:21] 。ご質問やご不明な点がありましたら担当
- [22:25] の弊社アカウントマネージャーまでお
- [22:28] 問い合わせください
- [22:29] 。ご視聴ありがとうございました。
